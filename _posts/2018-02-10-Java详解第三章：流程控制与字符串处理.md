---
layout:     post
title:      Java详解第三章：流程控制与字符串处理
subtitle:   循环、判断……任何代码语言对流程的控制都差不多
date:       2018-02-10
author:     GTH
header-img: img/post-20180210-bg.jpg
catalog: true
tags:
    - JAVA编程
    - GTH原创
    - JAVA教程
---

# 1.概述 #

流程控制在任何编程语言中都是基础中的基础，再复杂的程序与算法都是由这些流程控制语言组合起来的。

# 2.流程控制方法 #

Java流程控制包括顺序控制、条件控制和循环控制。

- 顺序控制，是最常见的控制方法。所谓顺序控制，就是从头到尾依次执行每条语句操作，没有任何的约束。

- 条件控制，顾名思义，就是基于条件选择执行语句，比方说，如果条件成立，则执行操作A，或者如果条件成立，则执行操作A，反之则执行操作B。条件之间相互独立时，还可以表达为a条件满足时执行操作A，b条件满足时执行条件B，c条件满足时执行操作C……

- 循环控制，又称为回路控制，根据循环初始条件和终结要求，执行循环体内的操作。

下面重点介绍条件控制和循环控制的语法。

# 3.流程控制语法 #

## 3.1 判断语句 ##

要约束条件控制和循环控制，必须要有一定的约束条件。所谓约束条件，从根本上看就是一个布尔值(true/false)。最常见的返回布尔值的是判断语句。一般的判断符号有：>、>=、<、<=、==、!=(~=)。

一个判断语句返回一个布尔值，如果每个条件之间有约束的话，那么这一个条件语句往往会包含多条条件语句。因此为了清晰表达多条与句之间的关系，我们需要关系符。常见的关系符有：与(&和&&)，或(|和||)，非(!和~)。

### ① &和&& ###

这两个都表示与的关系，所判断得到的结果是一样的，如下表所示(A&B)

| A \ B | true | false |
| :------: | :------: | :------: |
| **true** | true | false |
| **false** | false | false |

当且仅当A和B均为真时，得到的结果才为真；否则得到的结果为假。

> &和&&得到的结果虽然一致，但是他们处理的过程是不一致的。A&B处理时，会首先判断A和B的真假性，带入上面的表格中得到相应的结果；而A&&B处理时，会先判断A的真假性，如果A为真则会再去判断B的真假性，带入上面的表格中得到结果。而如果A为假，那么不管B是否为真，结果都是假，所以不会去判断B的真假性而直接输出结果。因此&&又被称为短路与。

### ② |和|| ###

这两个都表示或的关系，所判断得到的结果是一样的，如下表所示(A|B)

| A \ B | true | false |
| :------: | :------: | :------: |
| **true** | true | true |
| **false** | true | false |

当且仅当A和B均为假时，得到的结果才为假；否则得到的结果为真。

> |和||的关系和&与&&的关系一致，||又称短路或，A||B会优先判断A，如果A为假才会继续判断B，否则直接输出结果为真。

### ③ ~和! ###

这两个之间完全没有区别，都是表示非的意思，即将判断结果取反。

## 3.2 条件控制 ##

### ① if条件语句:关键词if ###

if条件语句语法格式:
	
	if(条件A){
	       执行语句A;
	}else if(条件B){
	       执行语句B;
	}else{
	       执行语句C;
	}

### ② switch条件语句:关键词switch ###

switch条件语句语法格式:

	switch(变量A){
		case 值a：
			执行语句A;
		break;
	    case 值b:
	 		执行语句B;
	 	break;
		case 值c：
	 		执行语句C;
	 	break;
	 	default:
			执行语句D;
	 	(break;)
	}

> 值得一提的是，switch-case语句中必须要有break，我们可以把switch语句想象成一条长廊，长廊左面一侧全是入口(case语句)，右面一侧全是出口(break语句)，一个入口对应一个出口，中间的过道是执行语句。正常人会从一个入口进，经过过道到另一个出口出。如果没有出口(break语句)，那么这个人要出去，就会进入下一个过道，如果下一个过道仍然没有出口，则会进入再下一个，直到找到出口出去为止。那么在这个过程中，系统就会执行别的条件语句，就不符合switch语句的功能了。有兴趣的话可以试一试不加break语句，看看结果如何。

## 3.3 循环控制 ##

### ① for循环语句:关键词for ###

for循环语句语法格式:

	for(变量初始值;约束条件;循环结束后执行语句){
		执行语句;
	}

语句中一共有三个参数语句，每条语句之间用分号隔开。当约束条件满足时执行语句，不满足时跳出循环，执行后面的语句。

### ② while循环语句:关键词while ###

while循环语句语法格式:

	while(条件A){
		执行语句A;
	}

程序刚运行到这条语句时会先判断条件A，结果为true时执行语句A，每次执行完后都会判断条件A，直到条件A不满足时跳出循环，执行后面的语句。

### ③ do-while循环语句:关键词do、while ###

do-while循环语句语法格式：

	do{
		执行语句B;
	}while(条件B);

程序刚运行到这条语句时会先执行语句B，然后判断条件B，结果为true则再次执行语句B，以次循环。每次执行完语句B后都会判断条件B，直到条件B不满足时跳出循环，执行后面的语句。

# 4.字符串处理 #

String类适用于描述字符串事物，它也提供了多个方法对字符串进行操作。

常用的方法如下：

<span id="jump1">（以下方法以字符串***String testStr = “abcdefgabcdefg”***为例）<span>

## 4.1 获取 ##

### 4.1.1 length ###

**int length()**：获取长度。这里的长度指的是字符串中包含的字符数。

> 如：[testStr](#jump1).length()得到的值为14。

### 4.1.2 charcharAt ###

**char charcharAt(int index)**：返回指定索引处的char值。（index从0开始）

> 如：[testStr](#jump1).charAt(3)得到的字符为d。

### 4.1.3 indexOf ###

**int indexOf(String str)**：返回的是str在字符串中第一次出现的位置。

> 如：[testStr](#jump1).indexOf("abc")得到的值为0。

**int indexOf(char ch, int fromIndex)**：从fromIndex指定位置开始，获取ch在字符串中出现的位置。

> 如：[testStr](#jump1).indexOf("abc", 1)得到的值为7。

**int lastIndexOf(int ch)**：反向索引一个字符出现的位置。

> 如：[testStr](#jump1).lastIndexOf('a')得到的值为7。

- 注意：str、ch都可以是String、char，当为String时，返回的是String中第一个字符的位置。如果返回-1表示该str 不在字符串中存在。

## 4.2 判断 ##

### 4.2.1 contains ###

**boolean contains(String str)**：判断字符串中是否包含某一个子串。

A.contains(str)判断等价于A.indexOf(str) == -1的判断，两个判断功能是一致的。

> 如：[testStr](#jump1).contains('x')得到的是false。

### 4.2.2 isEmpty ###

**boolean isEmpty()**：判断字符串中是否是空字符串。

A.isEmpty()等价于A.length() == 0的判断，两个判断功能是一致的。

> 如：[testStr](#jump1).isEmpty()得到的是false。

### 4.2.3 startsWith ###

**boolean startsWith(String str)**：判断字符串是否是以指定内容开头。

A.startsWith(str)等价于A.indexOf(str) == 0的判断，两个判断功能是一致的。

> 如：[testStr](#jump1).startWith("abc")得到的是true。

### 4.2.4 endsWith ###

**boolean endsWith(String str)**：判断字符串是否是以指定内容结尾。

A.endsWith(str)等价于A.lastIndexOf(str) == A.length() - str.length()的判断，两个判断功能是一致的。

> 如：[testStr](#jump1).endsWith("abc")得到的是false。

### 4.2.5 equals ###

**boolean equals(str)**：判断字符串内容是否相同。是重写了Object类中的equals方法。

> 如：[testStr](#jump1).equals(“ABCDEFabcdef”)得到的是false。

注意：判断两个字符串内容是否一致时，一般使用equals方法判断，而不是直接用==比较，因为==当且只当两个字符串是通过直接赋值时，才能正确判断，而如果字符串是通过别的方法获取值，比如截取字符串的方式获得值的情况下，==判断是错误的结果，而equal判断在任何情况下都通用。比如如下代码：

	String a = "Hello";
	String b = "Hello";
	String c = "Hel";
	String d = a.subString(0,3); //这个方法后面会介绍，表示从a字符串中下标为0的字符开始截取3个字符，这里值为"Hel"
	String e = 'H' + 'e' + 'l';
	
	a == b;			//true
	a.equal(b);		//true
	c == d;			//false
	c.equal(d);		//true
	c == e;			//false
	c.equal(e);		//true

由此可见，判断字符串值是否相等时用equals是不会出错的，而用==会出错，因为equals单纯的比较的两个字符串的值，而==比较的是两个字符串对象，字符串对象除了值这一个属性外还有许多其他的属性，当你通过直接赋值给空的字符串对象时，字符串对象除了值这一个属性外其他属性都是空的，这两个字符串对象自然就是相等的了；而你用String自带的函数赋值某个字符串对象时，这些自带的函数会改变这个字符串对象中其他一些属性的值，这样就算值这一个属性是相同的，两个字符串对象中其他属性不一致，自然==判断会判false。

### 4.2.6 equalsIgnoreCase ###

**boolean equalsIgnoreCase()**：在忽略大小写的前提下判断内容是否相同。

> 如：[testStr](#jump1).equalsIgnoreCase(“ABCDEFabcdef”)得到的是true。

## 4.3 转换 ##

### 4.3.1 将字符数组转换成字符串 ###

- 通过构造函数的方式：

**String(char[] data)**：将字符数组按顺序组合成字符串。

**String(char[] data, int offset, int count)**：将字符数组中以第offset个字符为始，取count个字符转换成字符串。

	char a[] = {'H','e','l','l','o'};
	String b = new String(a);			// b = "Hello"
	String c = new String(a, 1, 3);		// c = "ell"

- 通过String类的静态方法：

**static String copyValueOf(char[])**：将字符数组按顺序组合成字符串。

**static String copyvalueOf(char[] data, int offset, int count)**：将字符数组中以第offset个字符为始，取count个字符转换成字符串。

与构造函数类似，这两个方法是将字符数组转换成字符串并输出。也可以用ValueOf实现相同的功能，这两个函数具体的区别[下面会介绍](#jump2)。

调用静态方法，不需要实例化对象，直接用类名.方法名的方式引用即可。

	char a[] = {'H','e','l','l','o'};
	String b = String.copyValueOf(a);			// b = "Hello"
	String c = String.copyValueOf(a, 1, 3);		// c = "ell"

### 4.3.2 将字符串转换成字符数组 ###

**char[] toCharArray()**：将字符串转换成字符数组并输出。

> 如：[testStr](#jump1).toCharArray()得到的是{'a','b','c','d','e','f','a','b','c','d','e','f'}。

### 4.3.3 将字节数组转换成字符串 ###

**String(byte[] data)**：将字节数组按顺序组合成字符串。

**String(byte[] data, int offset, int count)**：将字节数组中以第offset个字节为始，取count个字节转换成字符串。

字节数组转换成字符串没有静态方法，只能通过构造函数实现转换。

### 4.3.4 将字符串转换成字节数组 ###

**byte[] getBytes()**：将字符串转换成字节数组并输出。

通常情况下很少用到字节与字符串的转换，但是如果将来到了通信之类的领域，前端后端之间的通信还是以byte传输为主，到那时需要用这几个方法相互转来实现字符串的传播。

### 4.3.5 将基本数据类型转换成字符串 ###

**static String valueOf(boolean b)**：返回 boolean 参数的字符串表示形式。

**static String valueOf(char c)**：返回 char 参数的字符串表示形式。

**static String valueOf(char[] data)**：返回 char 数组参数的字符串表示形式。

**static String valueOf(char[] data, int offset, int count)**：返回 char 数组参数的特定子数组的字符串表示形式。

**static String valueOf(double d)**：返回 double 参数的字符串表示形式。

**static String valueOf(float f)**：返回 float 参数的字符串表示形式。

**static String valueOf(int i)**：返回 int 参数的字符串表示形式。

**static String valueOf(long l)**：返回 long 参数的字符串表示形式。

**static String valueOf(Object obj)**：返回 Object 参数的字符串表示形式。

> <span id="jump2">这里说一下为什么已经有了valueOf函数可以实现字符数组转字符串的功能，String类还要专门再定义一个函数copyValueOf来实现相同的字符数组转字符串的功能，以及这两个函数有什么异同：</span>
> 
> 首先告诉你们一个好消息，现在随着java版本以及String类的更新，这两个方法已经没有什么本质上的区别了，功能完全是一致的，所以你们只需要记住一种方法即可。
> 
> 下面作为小知识，我来谈谈这两个方法吧。首先valueOf本质上传进的参数是Object类，别的类型其实都是继承了Object类的子类，而copyValueOf只能转换字符数组，所以valueOf方法的适用范围比copyValueOf广得多。那为什么还要定义这个范围又小功能又重复的方法copyValueOf呢？首先你们得知道，String的底层是由char[]实现的，也就是存放String的值的属性本质上是一个字符数组，而早期的String构造器的实现呢，不会拷贝数组的，所以valueOf方法直接将参数的char[]数组赋值给String的value属性，这就导致一个问题,如下代码所示：
> 
	//这是早期String构造器环境下的代码
	char a[] = {'t','e','s','t'};
	String b = String.valueOf(a);
	System.out.printf(b);//输出test
	a[0] = 'T';
	System.out.printf(b);//输出Test
>由此可见，由于是直接赋值，所以如果修改了字符数组a,字符串的值也会改变，这就会导致很多地方出错。为了避免这个问内题，便在String类里单独又做了一个静态方法copyValueOf，来单独做字符数组转字符串时的数组复制操作。
>
	//这是早期String构造器环境下的代码
	char a[] = {'t','e','s','t'};
	String b = String.copyValueOf(a);
	System.out.printf(b);//输出test
	a[0] = 'T';
	System.out.printf(b);//输出test
>但是现在的String对象，在构造器中就通过拷贝新数组实现了，所以这两个方面在本质上已经没区别了。

## 4.4 替换 ##

**String replace(char oldchar, char newchar)**：将字符串中所有字符oldchar替换成字符newchar。

> 如：[testStr](#jump1).repalce('a','A')得到的字符串为"AbcdefAbcdef"。

## 4.5 切割 ##

**String[] split(String regex)**：将字符串根据匹配给定的正则表达式regex来拆分字符串,返回分割后所有剩余的子串组成的字符串数组。

**String[] split(String regex, int limit)**：将字符串根据匹配给定的正则表达式regex来拆分字符串,返回前limit个子串组成的字符串数组。

- 注意： . 、 $、 | 、* 等转义字符，必须得加 \\\\。

- 多个分隔符，可以用 | 作为连字符。

如：

	String[] Address；

	Stringaddress1 = "地球,亚洲,中国";
	Address = address1.Split(",");
	
	Stringaddress2 = "地球\亚洲\中国";
	Address = address2.Split("\\");
	
	Stringaddress3 = "地球|亚洲|中国";
	Address = address3.Split("\\|");
	
	Stringaddress4 = "地球:亚洲:中国";
	Address = address4.Split("\\:");
	
	Stringaddress5 = "地球^亚洲^中国";
	Address = address5.Split("\\^");
	
	Stringaddress6 = "地球*亚洲*中国";
	Address = address6.Split("\\*");
	
	Stringaddress7 = "地球.亚洲.中国";
	Address = address7.Split("\\.");
	
	Stringaddress8 = "地球^亚洲@中国";
	Address = address8.Split("\\^|@");
 
以上字符创数组的内容完全一致：
 
	Address[0]="地球";
	 
	Address[1]="亚洲";
	 
	Address[2]="中国";

## 4.6 子串 ##

**String substring(int beginIndex)**：从第beginIndex个字符开始（起始索引是0）往后截取，返回截取后的子串。

> 如：[testStr](#jump1).substring(10)得到的字符串为"defg"。

**String substring(int beginIndex, int endIndex)**：从第beginIndex个字符开始（起始索引是0）往后截取到第endIndex个字符，返回截取后的子串。

> 如：[testStr](#jump1).substring(8,10) 得到的字符串为"bcd"。

## 4.7 转换 ##

### 4.7.1 转换大小写 ###

**String toUpperCase()**：将字符串中所有小写字母转成大写字母。

**String toLowerCase()**：将字符串中所有大写字母转成小写字母。

### 4.7.2 去除空格 ###

**String trim()**：将字符串两端的空格全部去除。

以上，便是我对流程控制与字符串处理相关知识与概念的理解和概括。欢迎大家在评论里讨论！